import argparse
import sys
import time
from pathlib import Path

from loguru import logger
from PIL import Image
from tqdm import tqdm


logger.remove() # Don't output anything if this is just being imported

class CombineError(Exception):
    """Raised when anything in the image combination process fails when
    no other type of exception would be applicable.
    """

class Combiner:
    """Takes a squaremap `tiles` directory path, handles calculating rows/columns,
    and is able to export full map images.
    """
    TILE_SIZE: int = 512
    """The size of each tile image in pixels.
    Only made a constant in case squaremap happens to change its image sizes in the future.
    """
    STANDARD_WORLDS: list[str] = ['overworld', 'the_nether', 'the_end']
    def __init__(self, tiles_dir: str | Path, use_tqdm = False):
        if not (tiles_dir := Path(tiles_dir)).is_dir():
            raise NotADirectoryError(f'Not a directory: {tiles_dir}')
        self.tiles_dir = tiles_dir
        self.mapped_worlds: list[str] = [p.stem for p in tiles_dir.glob('minecraft_*/')]
        self.use_tqdm = use_tqdm

    def combine(self, world: str | Path, detail: int) -> Image.Image:
        """Combine the given world (dimension) tile images into one large map.
        @param world: Name of the world to combine images of.
            Should be the name of a subdirectory located in this instance's `tiles_dir`.
        @param detail: The level of detail, 0 up through 3, to use for this map.
            Will correspond to which numbered subdirectory within the given world to use images from.
        """
        if world not in self.mapped_worlds:
            raise ValueError(f'No world directory of name "{world}" exists in "{self.tiles_dir}"')
        if not (0 <= detail <= 3):
            raise ValueError(f'Detail level must be between 0 and 3; given {detail}')
        source_dir: Path = self.tiles_dir / world / str(detail)
        columns: set[int] = set()
        rows: set[int] = set()
        regions: dict[int, dict[int, Path]] = {}

        # Sort out what regions we're going to stitch
        logger.info('Sorting through tile images...')
        for img in tqdm(source_dir.glob('*_*.png'), disable=not self.use_tqdm):
            col, row = map(int, img.stem.split('_'))
            if col not in regions:
                columns.add(col)
                regions[col] = {}
            if row not in regions[col]:
                rows.add(row)
                regions[col][row] = img

        # Start stitching
        out = Image.new(mode='RGBA', size=(self.TILE_SIZE * len(columns), self.TILE_SIZE * len(rows)))
        logger.info('Constructing image...')

        ta = time.perf_counter()
        for c in tqdm(regions, disable=not self.use_tqdm):
            for r in tqdm(regions[c], disable=not self.use_tqdm, leave=False):
                x, y = self.TILE_SIZE * (c - min(columns)), self.TILE_SIZE * (r - min(rows))
                out.paste(Image.open(regions[c][r]), (x, y, x + self.TILE_SIZE, y + self.TILE_SIZE))
        tb = time.perf_counter()

        logger.info(f'Finished in {tb - ta:04f}s')
        return out

@logger.catch
def main():
    logger.add(sys.stdout, format="{level}: {message}", level='INFO')

    #region ARGUMENTS
    # if anyone has suggestions for a less cumbersome way to do this than argparse i'm all ears
    parser = argparse.ArgumentParser()
    parser.add_argument('tiles_dir', type=Path, help='A tiles directory generated by squaremap.')
    parser.add_argument('world', type=str, help='Which world (dimension) you want to render a map of.')
    parser.add_argument('detail', type=int,
        help='What detail level to source images from.\n' +
        'Level 3 is 1 block per pixel, 2 is 2x2 per pixel, 1 is 4x4 per pixel, and 0 is 8x8 per pixel.')

    parser.add_argument('--output_dir', type=Path, default=Path('.'),
        help='Directory to save the completed image to.\n' +
        'Defaults to the directory in which this script was run.')

    parser.add_argument('--output_ext', type=str, default='png',
        help='The output file extension (format) to use for the created image. Supports anything Pillow does. (e.g. "png", "jpg", "webp")')

    parser.add_argument('--autotrim', type=bool, default=True,
        help='Automatically trims off excess empty space in the final image. Use "--autotrim false" to disable this.')

    parser.add_argument('--force_size', type=int, nargs='+', default=[0],
        help='Centers the assembled map inside an image of this size.\n' +
        'Can be used to make images a consistent size if you\'re using them for a timelapse, for example.')

    args = parser.parse_args()
    tiles_dir  : Path            = args.tiles_dir
    world      : str             = args.world
    detail     : int             = args.detail
    output_dir : Path            = args.output_dir
    output_ext : str             = args.output_ext
    autotrim   : bool            = args.autotrim
    if len(args.force_size) > 2:
        raise ValueError('--force_size argument can only take up to 2 integers')
    force_size : tuple[int, int] = tuple(args.force_size) if len(args.force_size) == 2 else (args.force_size[0], args.force_size[0])
    #endregion ARGUMENTS

    print(f"""
Tiles directory: {tiles_dir}
World: {world}
Detail level: {detail}
Output directory: {output_dir.absolute()}
Output file extension: {output_ext}
Auto-trim? {autotrim}
Force final size? {('True: ' + str(force_size)) if any(n > 0 for n in force_size) else 'False'}
    """)

    if world in Combiner.STANDARD_WORLDS:
        world = 'minecraft_' + world

    out_file: Path = output_dir / f'{world}-{detail}.{output_ext}'
    combiner = Combiner(tiles_dir, use_tqdm=True)
    image = combiner.combine(world, detail)
    if autotrim:
        box = image.getbbox()
        if not box:
            raise CombineError('image.getbbox() failed')
        logger.info(f'Trimming out blank space to leave an image of {box[2] - box[0]}x{box[3] - box[1]}...')
        image = image.crop(box)
    if all(n > 0 for n in force_size):
        resized = Image.new(mode='RGBA', size=force_size)
        logger.info(f'Resizing canvas to {resized.size[0]}x{resized.size[1]}...')
        center = resized.size[0] // 2, resized.size[1] // 2

        x1, y1 = center[0] - (image.size[0] // 2), center[1] - (image.size[1] // 2)
        x2, y2 = x1 + image.size[0], y1 + image.size[1]

        resized.paste(image, (x1, y1, x2, y2))
        image = resized


    logger.info(f'Saving to "{out_file}"...')
    image.save(out_file)
    logger.info('Done!')
