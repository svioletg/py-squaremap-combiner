import argparse
from pathlib import Path

from PIL import Image
from tqdm import tqdm

class CombineError(Exception):
    """Raised when anything in the image combination process fails when
    no other type of exception would be applicable.
    """

class Combiner:
    """Takes a squaremap `tiles` directory path, handles calculating rows/columns,
    and is able to export full map images.
    """
    TILE_SIZE: int = 512
    """The size of each tile image in pixels.
    Only made a constant in case squaremap happens to change its image sizes in the future.
    """
    STANDARD_WORLDS: list[str] = ['overworld', 'the_nether', 'the_end']
    def __init__(self, tiles_dir: str | Path, use_tqdm = False):
        if not (tiles_dir := Path(tiles_dir)).is_dir():
            raise NotADirectoryError(f'Not a directory: {tiles_dir}')
        self.tiles_dir = tiles_dir
        self.mapped_worlds: list[str] = [p.stem for p in tiles_dir.glob('minecraft_*/')]
        self.use_tqdm = use_tqdm

    def combine(self, world: str | Path, detail: int) -> Image.Image:
        """Combine the given world (dimension) tile images into one large map.
        @param world: Name of the world to combine images of.
            Should be the name of a subdirectory located in this instance's `tiles_dir`.
        @param detail: The level of detail, 0 up through 3, to use for this map.
            Will correspond to which numbered subdirectory within the given world to use images from.
        """
        if world not in self.mapped_worlds:
            print(world)
            print(self.mapped_worlds)
            raise ValueError(f'No world directory of name "{world}" exists in "{self.tiles_dir}"')
        if not (0 <= detail <= 3):
            raise ValueError(f'Detail level must be between 0 and 3; given {detail}')
        source_dir: Path = self.tiles_dir / world / str(detail)
        columns: set[int] = set()
        rows: set[int] = set()
        regions: dict[int, dict[int, Path]] = {}

        # Sort out what regions we're going to stitch
        for img in tqdm(source_dir.glob('*_*.png'), disable=not self.use_tqdm):
            col, row = map(int, img.stem.split('_'))
            if col not in regions:
                columns.add(col)
                regions[col] = {}
            if row not in regions[col]:
                rows.add(row)
                regions[col][row] = img

        # Start stitching
        out = Image.new(mode='RGBA', size=(self.TILE_SIZE * len(columns), self.TILE_SIZE * len(rows)))
        for c in tqdm(regions, disable=not self.use_tqdm):
            for r in tqdm(regions[c], disable=not self.use_tqdm, leave=False):
                x, y = self.TILE_SIZE * (c - min(columns)), self.TILE_SIZE * (r - min(rows))
                out.paste(Image.open(regions[c][r]), (x, y, x + self.TILE_SIZE, y + self.TILE_SIZE))

        return out

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('tiles_dir', type=Path, help='A tiles directory generated by squaremap.')
    parser.add_argument('world', type=str, help='Which world (dimension) you want to render a map of.')
    parser.add_argument('detail', type=int,
        help='What detail level to source images from.\n' +
        'Level 3 is 1 block per pixel, 2 is 2x2 per pixel, 1 is 4x4 per pixel, and 0 is 8x8 per pixel.')
    parser.add_argument('--output_dir', type=Path, default=Path('.'),
        help='Directory to save the completed image to.\n' +
        'Defaults to the directory in which this script was run.')
    parser.add_argument('--autocrop', type=bool, default=True,
        help='Automatically crops out excess empty space in the final image. Use "--autocrop false" to disable this.')

    args = parser.parse_args()
    tiles_dir: Path = args.tiles_dir
    world: str = args.world
    detail: int = args.detail
    output_dir: Path = args.output_dir
    autocrop: bool = args.autocrop

    print(f"""
Tiles directory: {tiles_dir}
World: {world}
Detail level: {detail}
Output directory: {output_dir}
    """)

    if world in Combiner.STANDARD_WORLDS:
        world = 'minecraft_' + world

    out_file: Path = output_dir / f'{world}-{detail}.png'
    combiner = Combiner(tiles_dir, use_tqdm=True)
    image = combiner.combine(world, detail)
    if autocrop:
        box = image.getbbox()
        if not box:
            raise CombineError('image.getbbox() failed')
        print(f'Cropping out blank space for a final image of {box[2] - box[0]}x{box[3] - box[1]}')
        image = image.crop(box)
    image.save(out_file)
    print(f'Saved to "{out_file}"')
